#+TITLE: TCP/IP protocol 101

* Internet and the OSI model

The internet is a global network interconnecting logically separated networks known as *Autonomous Systems* (*ASs*). Each AS manages communication through an
- Interior Gateway Protocol (IGP) :: Such as RIP or OSPF
- Exterior Gateway Protocol (EGP) :: Mainly BGP

The OSI model define a standard stack of communication protocols
- Layer 1 :: Physical layer (e.g. ethernet cable, optical fiber) uses *bits* as logic unit.
- Layer 2 :: Data link layer (e.g. ethernet, PPP) uses *data frames* as logic unit.
- Layer 3 :: Network layer (e.g. IPv4, IPv6) uses *packets* as logic unit.
- Layer 4 :: Transport layer provides reliability, uses *segments* as logic unit with connection protocols (e.g. TCP) and *datagrams* with connectionless protocols (e.g UDP).
- Layer 5 :: Session layer provides security (e.g. TLS, SSL) using *sessions*.
- Layer 6 :: Presentation layer is rarely implemented and usually mixed with the application layer.
- Layer 7 :: Application layer (e.g. HTTP, Telnet, DNS).

* Data link layer

The lowest logical layer interconnects physical interfaces, that are uniquely identified by a *MAC* address in a LAN. The MAC address is a 48-bit identifier (=HH-HH-HH-HH-HH-HH= in HEX notation), with the first 24 bits identifing the manufacturer (who assigns the last 24 bits). While the address should be uniquely assigned by the manifacturer, it can be easily changed by the user and shouldn't be used as security mechanism.

#+CAPTION: Frames are sent over ethernet on a broadcast and shared channel, the receiver is the only host that doesn't drop the frame.
[[./img/frame_example.jpg]]

* Network layer
** ARP, poisoning and MITM attack

The *Address Resolution Protocol* (*ARP*) is a declarative protocol used to discover MAC addresses associated with IP addresses. With ARP each hosts manages a cache table and can operate in two modes
- ARP request-response :: Hosts send a broadcast message request to ask for the MAC address of a given IP address.
- Gratuitous ARP (GARP) :: Hosts send a broadcast, gratuitous message response when joining a LAN.

#+CAPTION: Wireshark capturing an ARP request-reply
[[./img/ARP_rr_example.jpg]]

#+CAPTION: Wireshark capturing a broadcast request
[[./img/ARP_broadcast_example.jpg]]

Since ARP provides no authentication method, an attacker can continuously sends gratuitous ARP responses to poison the target ARP table and deliver a MITM attack. While the protocol works only in the confinement of the same network, such attack can be used in support of other techniques (e.g. DNS spoofing).

Mitigation can rely on
- Static ARP :: Set permanent entries on ARP cache (unsuitable for large and dynamic networks).
- Detection tools :: ARP poisoning is a very loud attack that can be detected by Intrusion Detection Systems.
- Packet filtering :: Disable gratuitous ARP replies, filter and inspect packets.
- Cryptography-based authentication :: Accept only authenticated ARP replies through cryptographic means (limited compatibility).

** IP and ICMP

*Internet Protocol* (*IP*) is a connectionless protocol for delivering packets from source to destination host, solely based on the IP addresses specified in the packet header. IP addresses are 32-bit (for IPv4) or 128-bit (for IPv6) identifiers dynamically (or statically) assigned.

A *subnet* is a logical division of an IP network: given an IP address, the most-significant bit-group is the routing prefix (the rest is the host identifier). The routing prefix can be expressed with two notations
- Classless Inter-Domain Routing (CIDR) :: e.g. =192.168.10.1/24= sets 24 bits for the routing prefix, 8 for the hosts.
- Subnet mask :: e.g. =255.255.255.0= is the subnet mask for =192.168.10.1/24=.

IPv4 addresses are divided in classes
- For standard communication
  - A :: =0.0.0.0/8-127.255.255.255/8=
  - B :: =128.0.0.0/16-191.255.255.255/16=
  - C :: =192.0.0.0/24-223.255.255.255/24=
- D :: =224.0.0.0-239.255.255.255=, used for multicast
- E :: =240.0.0.0-254.255.255.254=, experimental

Reserved private IPv4 network ranges are =10.0.0.0-10.255.255.255=, =172.16.0.0-172.31.255.255= and =192.168.0.0-192.168.255.255=.

The control plane for IP is in the hands of *Internet Control Message Protocol* (*ICMP*). Some ICMP message types include type 3 (Unreachable message), type 11 (time exceeded message), type 8 and 0 (Echo message and reply).

[[./img/icmp_header.jpg]]

The *traceroute* command relies on ICMP to display possible routes (paths) and measuring transit delays of packets across the network
- Sender starts by sending an ICMP echo to the destination with TTL=0.
- The first hop replies, and the sender takes note of its IP. If the reply is an unreachable message, the sender sends another ICMP echo with an increased TTL.
- The discovery ends when an echo reply is received.

** Fragmentation

The IPv4 header is variable in size due to the Options field: the IHL field contains the size of the IPv4 header, it has 4 bits that specify the number of 32-bit words in the header. It can range between 5 (5 × 32 bits = 160 bits = 20 bytes) and 15 words (15 × 32 bits = 480 bits = 60 bytes). The Options field guarantees some flexibility to the protocol, but also an entry point for an attacker to establish a covert channel.

#+CAPTION: IPv4 header
[[./img/ipv4_header.jpg]]

IP fragmentation breaks packets into fragments, so that the resulting pieces can pass through a link with a smaller Maximum Transmission Unit (MTU) than the original packet size. The fragments are reassembled by the receiving host.

Fields used for fragmentation are
- Identification :: 16 bits, identifies the group of fragments of a single IP datagram.
- Flags :: 3 bits, from most to least significant: bit 0 (reserved, must be zero), bit 1 (Don't Fragment, DF), bit 2 (More Fragments, MF).
- Fragment offset :: 13 bits, specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram in units of eight-byte blocks. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (213 – 1) × 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes.

Consider the following fragmentation example: we have 4,200 bytes of data to send over IP on an ethernet channel whose MTU is 1,500 bytes. With IPv4 fragmentation we have

|                 | Fragment A | Fragment B | Fragment C |
|-----------------+------------+------------+------------|
| IP header bytes |         20 |         20 |         20 |
| Data bytes      |       1480 |       1480 |       1240 |
| Identification  |       4452 |       4452 |       4452 |
| DF Flag         |          0 |          0 |          0 |
| MF Flag         |          1 |          1 |          0 |
| Offset          |          0 |       1480 |       2960 |

#+CAPTION: If an intermediate router has no timeout on fragment reassembly, a simple DoS attack can be mounted by a client sending a series of fragments for a packet,  none of them having zero offset.
[[./img/fragment_timeout.jpg]]

** DoS attacks

The ICMP protocol can be used to deliver several type of DoS attacks
- Ping flood :: The attacker leverages its superior bandwidth to overwhelm the receiver with ICMP echo requests.
- Ping of death :: A well-formed ping packet (header and data) is 64 bytes in size, but any IPv4 packet may be as large as 65,535 ($2^{16}-1$) bytes. The attacker can violate the protocol and exceed the MTU limit to cause a memory overlow and/or crash on the receiver side.

* Transport layer
** TCP and SYN Dos

*Transmission Control Protocol* (*TCP*) builds, over IP, a stateful channel to exchange data segments in a reliable, ordered, and error-checked way. A TCP connection is uniquely identified by source and destination addresses (IP) and their port (TCP), all stored in the header. Some destination ports are reserved (<1024, SSH:22, HTTP:80, HTTP:443, FTP:21), while the source port is randomly assigned.

#+CAPTION: The TCP header
[[./img/tcp_header.jpg]]

Code bits contains a set flags, among them
- SYN :: Only the first packet sent from each end should have this flag set.
- ACK :: All packets after the initial SYN packet sent by the client should have this flag set.
- FIN :: Last packet from sender
- RST :: Reset connection.
- Sequence number :: Has a dual role
  - SYN = 1 :: Initial sequence number, the sequence number of the actual first data byte and the acknowledged number in the corresponding ACK are then this sequence number plus 1.
  - SYN = 0 :: Accumulated sequence number of the first data byte of this segment for the current session.
- ACK number :: If the ACK flag is set then the value of this field is the next sequence number that the sender of the ACK is expecting. This acknowledges receipt of all prior bytes (if any). The first ACK sent by each end acknowledges the other end's initial sequence number itself, but no data.

#+CAPTION: TCP 3-way start (SYN) vs 4-way ending (FIN) handshake. Note that in 4-way the last client may abruptly close the connection without sending the last ACK, otherwise he waits for a time window to send the final ACK.
[[./img/TCP3+4hs.jpg]]

In states =SYN_RCVD= (server) and =ESTABLISHED= (client) both part establish a *Transmission Control Block* (*TCB*), a special data structure that stores information about the connection kept alive until the connection ends.

In a naive way, a server may be overloaded by TCP requests to open a connection, however
- The time frame where the attacker may act is limited by a timeout (usually 2 minutes)
- It is unlikely that the attacker can rely on a higher bandwidth with respect to the server
- The attacker's bandwidth can rapidly saturate since each message sent will get a response

A more sophisticated attack may involve (with IPv4) *spoofing*: sending packets with different source addresses and make the server respond to other hosts, making the attacker act in $O(n)$ instead of $O(2n)$. This attack in theory shouldn't work, since the an unsolicited =SYN;ACK= should be answered just with a reset that terminates the connection by the impersonated machine. However, the impersonated machines may in fact not respond at all (e.g. firewall dropping packets) and break the collaborative nature of IP.

Today the only possible defense are mitigation strategies such as *load balancing*, *rate limiter*, *proof of work*. A proof of work strategy tries to brake the asymmetry between sender, who has usually far easier job, and receiver by artificially augmenting the workload of the sender (the strategy shouldn't affect honest players).

In general, when a DoS is detected and mitigation measures are taken, the defense comes to late: ISPs are in a position to take preventive measures, but there is no economic benefit for them to do so since traffic generates revenues.

** TCP session hijacking and Mitnick attack

Given a server authorizing a whitelist of IP addresses (a bad practice), can an host not in the list reach the server?

If an attacker spoofs a whitelisted IP and send a =SYN= request its response will just reach the spoofed host. Pretending to be the client requires the attacker to know the client and destination IP, the port, the client =SEQN= and the server =SEQN= (the only missing information).

Hijacking the session requires the attacker to discover the server =SEQN=, either by
- Guessing the =SEQN= :: In the worst cast the attacker has $1/2^{32}$ chances to guess a randomly generated =SEQN=. The sequence might be easier to guess depending on the actual host implementation (=nmap= to find out the prediction difficulty).
- Eavesdrop :: If the attacker sits in the same network, he can sniff the server =SEQN=.

Having somehow guessed the server =SEQN=, the *Mitnick attack* exploits the race condition that raises between two packets reaching the server
- The attacker's =ACK= packet sent after the first =SYN= request.
- The legitimate client's =RST= packet in response to an unsolicited connection.
If the attacker predicts the correct =ACK= and manages to reach the server before the legitimate client (e.g. with the help of a DoS attack), the connection is established.

* Session, presentation and application layers
** Security protocols 101

Let's assume we have to design a car key system, where $CK$ is the car key and $\{m\}_K$ stands for "$m$ encrypted with $K$". Few implementations are possible, each with its drawbacks
1. Car and key share the same identifier $IDnr$, the car is opened when the key is in proximity.
   - By eavesdropping the air we can intercept the message and use it to open the car (replay attack).
2. Car and key share $\{{IDnr}\}_K$, an encrypted version of $IDnr$.
   - Still no protection against eavesdropping and replay attack.
3. Car and key share ${\{IDnr, Nonce\}}_K$, where a nonce is an arbitrary number that can be used only once and car must keep track of the past nonces.
   - This prevents replay attacks.

Finally, car and key may use a *challenge and response protocol*.
1. The car proposes a new challenge ${\{N\}}_K$ to the key
2. The key solves the challenge and responds with ${\{N+1\}}_K$
3. The car accepts the challenge and opens
Being the mechanism stateless, there is no issue of losing permanently syncronization and replay attacks are prevented.

** Secure channels

A *secure channel* is a pipe between two end points that implements a secure protocol
- Data origin authentication, data integrity and confidentiality are usually provided at this level.
- Non-repudiation and services that follows data reception may be delivered on higher levels.

Building a secure channel usually requires
- *Authentication* from the two parties (or just one) by sharing a fresh and secret *master key* $K$.
- *Key derivation* phase, where both parties derive *session keys* $K_1, K_2, \cdots, K_n$ from $K$.
  - *Mandatory access control* (*MAC*) key, to protect integrity and authenticity.
  - *Bulk encryption* key, to provide encryption.
- *Traffic protection* using the derived keys.
